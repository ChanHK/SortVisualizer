"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hydrate = hydrate;
exports.version = void 0;
require("../build/polyfills/polyfill-module");
var _client = _interopRequireDefault(require("react-dom/client"));
var _react = _interopRequireDefault(require("react"));
var _reactServerDomWebpack = require("next/dist/compiled/react-server-dom-webpack");
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
const version = "12.1.7-canary.19";
exports.version = version;
const appElement = document;
let reactRoot = null;
function renderReactElement(domEl, fn) {
    const reactEl = fn();
    if (!reactRoot) {
        // Unlike with createRoot, you don't need a separate root.render() call here
        reactRoot = _client.default.hydrateRoot(domEl, reactEl);
    } else {
        reactRoot.render(reactEl);
    }
}
const getCacheKey = ()=>{
    const { pathname , search  } = location;
    return pathname + search;
};
const encoder = new TextEncoder();
let initialServerDataBuffer = undefined;
let initialServerDataWriter = undefined;
let initialServerDataLoaded = false;
let initialServerDataFlushed = false;
function nextServerDataCallback(seg) {
    if (seg[0] === 0) {
        initialServerDataBuffer = [];
    } else {
        if (!initialServerDataBuffer) throw new Error('Unexpected server data: missing bootstrap script.');
        if (initialServerDataWriter) {
            initialServerDataWriter.enqueue(encoder.encode(seg[2]));
        } else {
            initialServerDataBuffer.push(seg[2]);
        }
    }
}
// There might be race conditions between `nextServerDataRegisterWriter` and
// `DOMContentLoaded`. The former will be called when React starts to hydrate
// the root, the latter will be called when the DOM is fully loaded.
// For streaming, the former is called first due to partial hydration.
// For non-streaming, the latter can be called first.
// Hence, we use two variables `initialServerDataLoaded` and
// `initialServerDataFlushed` to make sure the writer will be closed and
// `initialServerDataBuffer` will be cleared in the right time.
function nextServerDataRegisterWriter(ctr) {
    if (initialServerDataBuffer) {
        initialServerDataBuffer.forEach((val)=>{
            ctr.enqueue(encoder.encode(val));
        });
        if (initialServerDataLoaded && !initialServerDataFlushed) {
            ctr.close();
            initialServerDataFlushed = true;
            initialServerDataBuffer = undefined;
        }
    }
    initialServerDataWriter = ctr;
}
// When `DOMContentLoaded`, we can close all pending writers to finish hydration.
const DOMContentLoaded = function() {
    if (initialServerDataWriter && !initialServerDataFlushed) {
        initialServerDataWriter.close();
        initialServerDataFlushed = true;
        initialServerDataBuffer = undefined;
    }
    initialServerDataLoaded = true;
};
// It's possible that the DOM is already loaded.
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);
} else {
    DOMContentLoaded();
}
const nextServerDataLoadingGlobal = self.__next_s = self.__next_s || [];
nextServerDataLoadingGlobal.forEach(nextServerDataCallback);
nextServerDataLoadingGlobal.push = nextServerDataCallback;
function createResponseCache() {
    return new Map();
}
const rscCache = createResponseCache();
function useInitialServerResponse(cacheKey) {
    const response = rscCache.get(cacheKey);
    if (response) return response;
    const readable = new ReadableStream({
        start (controller) {
            nextServerDataRegisterWriter(controller);
        }
    });
    const newResponse = (0, _reactServerDomWebpack).createFromReadableStream(readable);
    rscCache.set(cacheKey, newResponse);
    return newResponse;
}
const ServerRoot = ({ cacheKey  })=>{
    _react.default.useEffect(()=>{
        rscCache.delete(cacheKey);
    });
    const response = useInitialServerResponse(cacheKey);
    const root = response.readRoot();
    return root;
};
function Root({ children  }) {
    if (process.env.__NEXT_TEST_MODE) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        _react.default.useEffect(()=>{
            window.__NEXT_HYDRATED = true;
            if (window.__NEXT_HYDRATED_CB) {
                window.__NEXT_HYDRATED_CB();
            }
        }, []);
    }
    return children;
}
const RSCComponent = ()=>{
    const cacheKey = getCacheKey();
    return(/*#__PURE__*/ _react.default.createElement(ServerRoot, {
        cacheKey: cacheKey
    }));
};
function fetchFlight(href) {
    const url = new URL(href, location.origin);
    const searchParams = url.searchParams;
    searchParams.append('__flight__', '1');
    return fetch(url.toString());
}
function useServerResponse(cacheKey) {
    let response = rscCache.get(cacheKey);
    if (response) return response;
    response = (0, _reactServerDomWebpack).createFromFetch(fetchFlight(getCacheKey()));
    rscCache.set(cacheKey, response);
    return response;
}
const AppRouterContext = /*#__PURE__*/ _react.default.createContext({});
// TODO: move to client component when handling is implemented
function AppRouter({ initialUrl , children  }) {
    var ref;
    const initialState = {
        url: initialUrl
    };
    const previousUrlRef = _react.default.useRef(initialState);
    const [current, setCurrent] = _react.default.useState(initialState);
    const appRouter = _react.default.useMemo(()=>{
        return {
            push: (url)=>{
                previousUrlRef.current = current;
                setCurrent(_objectSpread({}, current, {
                    url
                }));
                // TODO: update url eagerly or not?
                window.history.pushState(current, '', url);
            },
            url: current.url
        };
    }, [
        current
    ]);
    // @ts-ignore TODO: for testing
    window.appRouter = appRouter;
    console.log({
        appRouter,
        previous: previousUrlRef.current,
        current
    });
    let root;
    if (current.url !== ((ref = previousUrlRef.current) === null || ref === void 0 ? void 0 : ref.url)) {
        // eslint-disable-next-line
        const data = useServerResponse(current.url);
        root = data.readRoot();
    }
    return(/*#__PURE__*/ _react.default.createElement(AppRouterContext.Provider, {
        value: appRouter
    }, root ? root : children));
}
function hydrate() {
    renderReactElement(appElement, ()=>/*#__PURE__*/ _react.default.createElement(_react.default.StrictMode, null, /*#__PURE__*/ _react.default.createElement(Root, null, /*#__PURE__*/ _react.default.createElement(AppRouter, {
            initialUrl: location.pathname
        }, /*#__PURE__*/ _react.default.createElement(RSCComponent, null))))
    );
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=app-index.js.map